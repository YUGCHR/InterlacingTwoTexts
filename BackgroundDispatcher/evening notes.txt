
 так что сохраняем в список только чистые номера книг, для текущего тестового набора их будет 5
 кстати, можно сделать переключатель для загрузки книг в тестовый набор через ключ SettingsX
 а в качестве значения класть количество пар книг, которые заедут в тестовый набор - потом ключ автоматически сбросится (удалится)
 
 после того, как будет сформирован пакет задач (и созданы записи в вечном логе)
 пришло время создавать заказанный (при вызове метода) тестовый набор
 в параметрах указано количество пар (если положительный) или количество случайно выбранных отдельных книг (если отрицательный) - 

 например, допустим, нужна стандартная одна пара (можно сделать её умолчанием последнего параметра в вызове)
 тогда надо взять одно случайное значение в списке номеров книг
 (проверить, что номеров больше, чем нужно создать пар - нет, сейчас ещё нет смысла это проверять)
 и создать номер парной книги (плюс сдвиг), после этого проверить в вечном логе, что они обе есть (сразу достав их из лога)
 если какой-то нет, то взять следующее значение из списка номеров, общее количество уже есть (считали для случайного выбора),
 проверить, что следующий индекс не выходит за границу списка и взять его, если выходит, то взять нулевой

 ещё есть вариант, когда нужны несколько версий одной и той же книги, парами или в разброс
 скажем, надо тестировать сценарий, когда есть версии книги в базе/логе и надо загрузить новую версию
 или проверить, как отбрасывается там же самая версия, пары или одной из книг

 наверное, одним параметром сценарий данного теста не задать
 тогда для начала надо составить список сценариев и их кодирование (ключами или параметрами)

 1 простая пара книг, случайный номер, самая первая версия
 2 простая пара книг, случайный номер, новая версия от уже существующей
 3 простая пара книг, случайный номер, так же самая версия, что уже существует
 3а - (дальнейшее развитие) один из языков существует, второй нет
 4 - три пары книг
 5 - две пары книг и через 5 сек минус регулируемые проценты ещё пара книг
 5а - две пары книг и через 5 сек минус регулируемые проценты ещё две пары книг

 то есть, 5 вариант - общее описание - х пар, ожидание у сек, z пар, повторить подряд n раз (вариант 4 отпадает, реализуется пятым)
 далее варианты 4-5, но не все пары с уникальными номерами, а сколько-то номеров и сколько-то версий каждого номера
 то есть общее для всех сценариев описание - 
 х-1 пар / из них х-2 версий / 
 если х-2 равно (или больше) первого, то все пары уникальные, если меньше, то это количество уникальных пар, остальные версии
 х-3 непарных книг, просто добавляются отдельные, не должны совпадать даже частично с предыдущим набором
 ожидание у сек, может быть 0,
 z пар, настройка аналогична первому набору,
 повторить подряд n раз

 надо быть проще

 скажем, первое число - 0, 1 или 2, соответственно англ, рус или пара
 второе число - в том же диапазоне значит версия первого варианта, +10 - то же самое, но новая книга
 аналогично с +10 задаются следующие шаги - можно выбрать новую книгу или любую из бывших

 0, 1 и 2 убираем, можно только 10-12, 20-22 и так далее, номеров тестовых книг вряд ли будет сильно больше десятка
 потом можно добавить, что 0 - отметка начала повтора, 1 - конец и потом идёт число повторов

 но тестовых книг не так много, чтобы так расходиться, оставим на (далёкое) будущее

 отрицательное число в ряду - задержка в миллисекундах, зная задержку таймера из констант, 
 можно подбираться ближе к срабатыванию с разных сторон, добиваясь сдвоенного срабатывания (или нет)
 можно сразу в одном ряду проверять несколько задержек, скажем -

 12, 22, -4700, 32, -1000,
 12, 22, -4800, 32, -1000,
 12, 22, -4900, 32, -1000

 будет означать, что взять пару книг с номером 73 (к примеру) первой версии, потом пару 75 и,
 после задержки 4,7 сек, пару 77, потом на всякий случай секунду (и ещё вариант без неё)
 и повторить с другой версией и другой задержкой

 как тогда сделать повтор той же книги?
 можно перейти к трёхзначным числам и последняя цифра будет версией

 если версий/номеров не хватает, ряд (сценарий) заканчивается с оповещением, чего не хватило

 тогда такой вид -
 121, 221, -4700, 321, -1000,
 122, 222, -4800, 322, -1000,
 123, 223, -4900, 323, -1000

 три пары книг по три разных версии каждой
 если в версии 0, это может означать взять следующую версию автоматически

 аналогично, с номерами книг -
 2, 2, -4700, 2, -1000,
 2, 2, -4800, 2, -1000,
 2, 2, -4900, 2, -1000

 может означать, что каждый раз брать новую пару книг, пока не кончатся, потом брать следующие версии
 и после теста надо же проверить ключи кафе и понять, соответствуют ли они заявленным требованиям

 тогда параметр сценария может быть либо массивом (списком) целых чисел, либо ключом, 
 в котором поле это индекс массива, а в значении значение
 ключ выглядит более заманчиво, особенно, когда его надо будет передать из веб-интерфейса

 порядок действий примерно такой -
 смотрим первый элемент/значение, если пара, берём обе книги первой версии, 
 первого номера (или случайного, как обозначить?), соответственно, если одна,
 то берём одну из, вторую вычёркиваем, не будем вообще использовать
 смотрим следующий индекс - берём или следующую книгу или следующую версию этой же,

 для этого предварительно можно выстроить все полученные из вечного лога книги/языки/версии в двухмерный массив
 или хватит и одномерного? - нужно иметь номера книг (например) по порядку,
 у каждого номера должно быть количество версий и (желательно) языков

 вообще - то примерно так они и организованы в вечном логе

 тогда создаём список гуид-полей следующим образом - берём номер книги
 (для определённости скажем случайный и книги парами, одиночные тоже понятно как),
 достаём оба списка версий из номерных полей пары, сразу удаляем из списков пустышки
 (можно это и раньше было сделать, ещё при создании, может так и надо реализовать)
 берём первую (с нулевым индексом - или лучше последнюю?) версию,
 достаём из списка гуид-поле текста книги (обоих книг) и складываем в выходной список по порядку

 второй такой же список, только инт, делаем с задержками, потом когда будем считывать список книг для генерации событий,
 параллельно будем смотреть в список задержек с таким же индексом, 0 - нет задержки и так далее

 пустышки не удаляем ни в коем случае, ни сейчас, ни раньше -
 когда в отдельно взятом списке останется только пустышка, просто удалим это поле

 после того, как будут готовы выходные списки - один с гуид-полями, другой с задержками, надо удалить всё лишнее -
 1 все тестовые поля из вечного лога, теперь не надо что-то оставлять, чтобы посмотреть на наложение (повтор книги),
 это можно предусмотреть в сценарии
 2 удалить образовавшийся пакет задач (хотя можно и оставить для сравнения,
 отредактировав его в соответствии с выходным списком - просто удалив ненужные поля)

 нет, возиться с пакетом задач нет смысла, просто удалить -
 пакет всё же лучше не удалять, а привести в нужное состояние и использовать для сравнения
 хотя там есть вычисленные хэши и версии хэшей, надо ещё подумать над его использованием

 кстати, метод, который за контроллером пишет ключ с книгой, а потом ключ с оповещением,
 надо вынести в общую библиотеку и потом его же использовать в тесте
 (там, наверное, стоит регулируемая задержка между записями или проверка записи книги) -
 чтобы тест точно совпадал с рабочим вариантом

 и надо при проверке результатов не пытаться состязаться с серверами в чтении ключа кафе,
 а тихо и спокойно получить ключ пакета задач до создания ключа кафе -
 метод, создающий ключ кафе перед его записью может проверить, не тест ли сейчас
 и сразу передать ключ в эту проверку (или в отдельный следующий вызов) 

 а за ключом кафе, как и предполагалось, просто смотреть со стороны - как его едят

