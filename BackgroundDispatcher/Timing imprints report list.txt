
общая концепция тестов с контролем времени прохождения задачи в контрольных точках

проводятся тесты, создающие профили времени работы всех методов, по которым проходит задача (по ключевым точкам)
каждая ключевая точка сообщает свой номер, имя метода, засечку секундомера, относительный номер задачи и ещё много всего
по итогам теста получается список внутреннего класса - данных от всех ключевых точек, 

этот список записывается в базовый класс и дополняется некоторыми данными (номер сценария и прочее)
потом список записывается в список всех отчётов и сохраняется в ключе отчётов в поле с номером сценария
получается, что сохраняются все тестовые отчёты с начала времён по всем сценариям

в свободное время сервер запускает тесты, для которых не хватает отчётов

все отчёты хранить бессмысленно, поэтому как накапливается 5 свежих отчётов, проводится их сравнение, 
если они одинаковые, то создаётся эталонный отчёт и записывается в нулевой индекс списка, остальные удаляются
следующие отчёты сравниваются с эталонным и сохраняется только последний (несколько последних, если такое указано а настройках)

ещё в момент создания эталонного ему присваивается версия (по порядку) и все следующие отчёты, совпадающие с ним, маркируются той же версией
если приезжает новый отчёт, несовпадающий с эталонным, он просто записывается в конец списка без версии
когда таких (без версий) накапливается 5 штук, производится сравнение и, возможно, создание нового эталонного отчёта (новой версии)

тогда старый эталон изгоняется с нулевого индекса на первый (или на первый незанятый бывшим эталонным отчётом), а новый записывается на нулевой
далее, удаляются все отчёты с версией разжалованного, а затем и все последние версии со свежеприсвоенной версией, кроме самого последнего - он сохраняется последним
если отчёты без версий сильно не совпадают - нет далее двух (трёх?) последних совпавших, привлекается внимание оператора
если совпали хотя бы два (или более, в настройках) последних, остальные просто удаляются

таким образом, можно быть более уверенным, что успешно прошедший тест означает стабильную работоспособность сервера

1. CreateAssignedSerialNum - получает номер сценария
(поменять имя на более подходящее)
метод достаёт из хранилища (key eternalTestTimingStagesReportsLog) список отчётов, 
соответствующий полученному тестовому сценарию
если список имеет нулевую длину - создать элемент-пустышку и записать в список
(метод, достающий список, подменяет null правильным типом списка нулевой длины)
если в списке что-то есть, проверить, является ли нулевой элемент эталоном и установить флаг (?)
затем проверить остальные элементы (можно с конца списка) на предмет нулевой версии 
и как только встретился номер версии, установить счётчик количества без версий
вернуть из метода собственно список, флаг эталона и количество отчётов без версий

2. AddStageToTestTaskProgressReport - получает много всего
метод занимается другими делами, но его надо нагрузить дополнительной функцией - посчитать хеш всего, что записывает
у него удобная позиции доступа к данным, в других местах их придётся сначала достать, распаковать, потом обратно
метод получает кучу данных, включая засечки секундомера от рабочих методов по мере прохождения задач, 
записывает их во внутренний класс (базового) и потом записывает во временный ключ
ну и ещё всякие полезные мелочи по теме
самое простое, создать строку, записать в неё по очереди все данные, кроме отметок времени и счётчиков вызовов 
и отправить её за получением хеша (есть метод в утилитах}
полученный хеш записать в этот же внутренний класс (выше не получится, метод не работает с базовым классом)

3. 



метод отдающий список отчётов на старте может ещё отдать признак, есть ли эталонный и сколько есть отчётов выше него
с признаком эталона можно пока не спешить
многовато, но удобно - в конце метод примет это и решит, надо ли сравнивать текущий или просто записать
кстати, надо ещё проверять версии и набирать 5 без версий - только тогда выдавать признак
если отчётов хватает для сравнения, вызвать сравнение
сравнить длины, потом последовательно сравнивать по полям, но в одном и том же цикле (наверное)
можно делать хэши для каждого отчёта при его очередном переборе в подходящем месте - только без времени
можно взять отчёт, удалить поля времени, сериализовать в строку джейсона и взять хеш
во время записи шага отчёта считать хеш данных - без счётчиков параллельных вызовов
записать хеш в поле класса, а потом сумму хешей или хеш хешей в базовый класс
для версий надо где-то хранить список хешей
правда, тут уже и есть список и в нём хеши

по поводу версий - в эталоне самая последняя версия, а старых можно хранить несколько штук, от десятка до трёх, по мере отладки
допустим, уже есть эталонная и к ней одна (несколько) более свежих, но таких же
если появляется новая другая, то через 5 тестов она вытесняет эталонную (её можно переписать в первую, если она была такой же версии), тогда первые несколько штук (после вытеснения старой эталонной можно оставить только её под индексом 1, а остальные удалить) остаются старыми - всё более старыми по мере обновления версий
надо попробовать расписать это в виде диаграммы




дальше надо сравнить последний элемент списка в ключе с предпоследним и создать какой-то признак

можно сначала сравнить количества элементов, потом первые три поля - включая названия методов, а потом уже времена (и остальное)

порядок работы с ключом слепков -
перед записью очередного прохода посмотреть в список из ключа
есть там эталонный (с индексом 0) список или нет
есть ли кроме эталонного ещё (обычно всегда должен быть хоть один)
скажем, в начале эталонного нет, вместо него пустышка и следующего (с индексом 1 тоже нет), тогда просто записываем текущий прогон в индекс 1
аналогично следующие 4 - пока нет эталонного, надо накопить 5 отчётов, чтобы решить насчёт эталонного

когда эталонного нет, а есть 5 (из констант) элементов, то по готовности шестого вызвать метод сравнения (и, если повезёт, записи эталонного)
провести сравнение всех 5 списков с шестым, если примерно совпадают (технология описана выше), создать средние значения времён (можно хранить допустимое максимальное отклонение для всех проверенных списков, придётся для каждого времени - ещё одно поле класса, но можно общее в процентах, тогда можно разместить в базовом классе)

если с созданием эталонного всё получилось, то записываем его, 5 предыдущих удаляем, а шестой записываем с индексом 1

теперь каждый новый тест будет сравниваться с эталонным и если совпадает, записываться на место с индексом 1 (там всегда будет самый свежий тест)

можно (управлять константой) сколько последних тестов держать - при отделке можно хранить 3 или 5, а потом один

если новый тест отклонился от эталона, он записывается со следующим индексом - пока опять не наберётся 5 новых

тут придётся добавить версию отчётов

версия присваивается после проведения сравнения, пока его не было, она, скажем, нулевая или -1








устроить проверку, что если несколько минут нет рабочих задач, то можно крутить тесты
наличие рабочих задач можно засечь по обращениям за полем есть-сейчас-тест (а как ещё можно?)
но сервер, постоянно занятый тестами, нафиг не нужен - они же блокируют прохождение задачи
тогда надо сохранять задачу и держать её, пока идёт тест - и решить как быть, если приедет ещё одна задача
надо чтобы тестовые задачи ехали одновременно с рабочими, точнее наоборот
наверное, нужно какое-то короткое айди тестовой задачи и по нему рабочие методы будут писать отчёт
или писать отчёт на все задачи, наверху разберутся (но как?)


