@startuml

#pink:Integration health check;
#lightblue:IntegrationTestService;
:_isTestInProgress set true;
:Set the local constants;
if (Graphviz installed?) then (yes)
  :process all\ndiagrams;
else (no)
  :process only
  __sequence__ and __activity__ diagrams;
endif

repeat
  :Test something;
    if (Something went wrong?) then (no)
      #palegreen:OK;
      break
    endif
    ->NOK;
    :Alert "Error with long text";
repeat while (Something went wrong with long text?) is (yes) not (no)
->//merged step//;
:Alert "Success";

#lightgreen:SubscribeOnEventFrom;
#coral:EventFromOccured;
#lightgreen:SubscribeOnEventСafeKey;
#coral:SubscribeOnEventСafeKey;
#lightgreen:SubscribeOnEventKeyTest;
#coral:SubscribeOnEventСafeKey;

@enduml

порядок работы встроенного интеграционного теста (далее health check) -
  поле "тест запущен" _isTestInProgress ставится в true - его проверяет контроллер при отправке задач
  устанавливаются необходимые константы
  записывается ключ глубины теста test1Depth-X - в нём хранится название метода, в котором тест должен закончиться
  *** потом надо переделать глубину в список контрольных точек, в которых тест будет отчитываться о достижении их
  удаляются результаты тестов (должны удаляться после теста, но всякое бывает)
  достаётся из ключа запуска теста номер (вариант) сценария
  вызывается _convert.CreateTestScenarioKey и создаётся сценарий - временно по номеру
  *** потом из веба будет приходить массив инт с описанием сценария
  *** добавить в метод необязательный параметр массив инт
  *** дальше надо думать с определением номера сценария - по идее больше это не нужно, выбранный сценарий хранится в ключе

  вызывается _prepare.CreateTestBookPlainTexts и создается комплект тестовых книг
  для этого обращаемся к стационарному хранилищу тестовых книг в ключе storageKeyBookPlainTexts
  *** потом их надо уметь удобно обновлять и хранить копии в базе (в специальном разделе?)
  вызывается _store.CreateTestBookIdsListFromStorageKey
  общее назначение метода - создать два списка - номеров книг и мест хранения (название поля в хранилище)
  для этого создаём два новых списка -
  int uniqueBookIdsFromStorageKey - уникальные номера книг и string guidFieldsFromStorageKey - названия полей в хранилище
  проверяем наличие ключа хранилища
  выгружаем всё хранилище в словарь
  перебираем пары <string, TextSentence>
  название поля string сразу записываем в новый список
  достаём номер книги из очередного TextSentence и проверяем его наличие в новом списке номеров
  если такого номера ещё нет, добавляем его в список
  возвращаем из метода два списка (очевидно несинхронные и разной длины)

  вызывается RemoveTestBookIdFieldsFromEternalLog
  используя список уникальных ключей, надо удалить все тестовые ключи из вечного лога
  здесь для первичной очистки и для контроля (вдруг по дороге упадёт и ключи останутся)

  вызывается _collect.CreateTaskPackageAndSaveLog
  вне теста этот метод используется для для создания ключа готового пакета задач -
  с последующей генерацией (другим методом) ключа кафе для оповещения о задачах бэк-сервера
  сохраняются названия гуид-полей книг, созданные контроллером, но они перезаписываются в новый ключ, уникальный для собранного пакета
  одновременно, при перезаписи содержимого книг, оно анализируется (вычисляется хэш текста) и проверяется на уникальность
  если такая книга уже есть, это гуид-поле удаляется
  здесь этот метод используется для записи хэшей в вечный лог -
  при этом вычисляются номера версий загружаемых книг, что и нужно вызывающему методу

  вызывается _scenario.CreateTestScenarioLists - этот метод из ключа описания сценария
  создаёт последовательность (список string rawPlainTextFields) гуид-полей сырых текстов
  и задержек между ними (List<int> delayList) - и это синхронные списки
  используется значение из того, где оно не нулевое

  и опять вызывается RemoveTestBookIdFieldsFromEternalLog - удалить все тестовые ключи из вечного лога второй раз -
  после завершения использования для подготовки тестовых текстов

  вызывается CreateScenarioTasksAndEvents
  создать из полей временного хранилища тестовую задачу, загрузить её и создать ключ оповещения о приходе задачи

