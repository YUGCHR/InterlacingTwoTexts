# InterlacingTwoTexts
BookTextsSplit with backservers

1. Оописание работы сервера-диспетчера BackgroundDispatcher

основное назначение - собрать одиночные задачи в пакеты и отдать в обработку бэк-серверам BackgroundTasksQueue (серверам фоновой загрузки книг)
особенно полезно собрать минимальный пакет из пары книг - на разных языках, в большинстве случаем именно это будет основным кейсом

дополнительные задачи - 
хранение "вечного" лога исходников загруженных книг с контролем повтора книг
выполнение интеграционных тестов - несколько сценариев и различные глубины выполнения
контроль прохождения рабочих задач через сервер и получение их бэк-сервером
выполнение запроса контроллера о состоянии отправленной на загрузку книги - выполнено или нет и почему

основные сценарии интеграционных тестов -
пара книг (на обоих языках) проходит цепочку от загрузки как бы контроллером и до появления и исчезновения ключа кафе - пакет принят бэк-сервером в обработку
загрузка сначала двух пар книг и через 4,7 - 4,9 секунды загрузка ещё двух пар - ожидание почти окончания таймера и перегрузка лишними задачами - 
проверка как обрабатываются лишние задачи после 6-ти (6 задач сразу обрабатываются в пакет)
добавление третьей задачи во время работы таймера, ближе к окончанию - проверка, что произойдёт с нечётной задачей (она должна удалиться, но пользователь должен получить уведомление)

описание работы сервера -
при старте сервера загружаются константы из общего ключа и оформляются подписки -
SubscribeOnEventFrom - на ключ задач от контроллера,
SubscribeOnEventСafeKey - на ключ кафе,
SubscribeOnTestEvent - на ключ запуска тестов,
после этого сервер стоит в ожидании команд

при событии подписки на ключ задач subscribeOnFrom вызывается многопоточный (пока не проверено) обработчик EventCounterOccurred, 
который увеличивает блокируемый (атомарный) счётчик, одновременно проверяет уже насчитанное количество задач и, если количество достигло одного из установленных порогов - 
2 задачи - запускает таймер, 6 задач - сразу вызывает обработчик слияния вызовов HandlerMergeOfCalling

после получения второй задачи запускается таймер (на 5 сек, все параметры регулируются в константах и могут быть изменены в период простоя сервера), 
по окончанию таймера вызывается обработчик слияния вызовов HandlerMergeOfCalling

метод обработчик слияния вызовов HandlerMergeOfCalling останавливает таймер (если вызов пришёл не от него, а по верхнему порогу количества задач) и затем устанавливает
блокировку сдвоенного вызова себя - от счетчика и таймера одновременно - включая ожидание для повторного вызова
дальше вызывается распределитель вызовов обработчиков HandlerCallingsDistributor, который должен обработать несколько потоков, если такие возникнут

HandlerCallingsDistributor - метод распределитель вызовов обработчиков вначале немного отвлекается на работу с тестами
(проверяет - тест сейчас или нет и, если тест, сообщает ему о достигнутом пункте прохождения задачи),
затем вызывает метод обработчик вызовов HandlerCallings и сразу, не ожидая от него возврата, возвращает команду снятия блокировки сдвоенного вызова, 
позволяя прохождение следующей задачи (тут должна реализоваться многопоточность, но тестов ещё не было)

HandlerCallings - метод обработчик вызовов (надо переименовать - обработчик вызовов от событий подписки) вызывает по порядку все остальные методы класса -
метод ProcessDataOfSubscribeOnFrom - обработать данные ключа subscribeOnFrom
метод BackgroundDispatcherCreateTasks создания пакета задач (переименовать?)
и, при возврате не null из BackgroundDispatcherCreateTasks, метод DistributeTaskPackageInCafee

метод обработки данных ключа subscribeOnFrom ProcessDataOfSubscribeOnFrom находит в ключе сообщения о задачах subscribeOnFrom поля с bookText:bookGuid:guid задач,
везде в значениях находится общий ключ bookPlainTexts:bookSplitGuid:guid всех задач текущего сеанса книжного сервера
метод считывает в словарь все поля и значения из ключа (значение сразу сохраняется) и потом перебирает все поля, пробуя их удалить,
после успешного удаления поле записывается в новый список задач для пакета, который и возвращает этот метод (и еще возвращает ключ bookPlainTexts:bookSplitGuid:guid)
поскольку этот обработчик многопоточный, возможно, что рядом трудится с этим же ключом второй экземпляр и поля, которые не удалось удалить, отбрасываются, 
не попадая в новый список, но складываются в отдельный список для последующего контроля (пока не реализовано)

по имени поля bookText:bookGuid:guid контроллер может получить дальнейший доступ к информации о ходе обработки задачи и уведомлению о её окончании (успешном или нет)

далее, следующий метод BackgroundDispatcherCreateTasks расположен в классе тестов, поскольку он выполняет сходную задачу для тестов
(или ещё дальше, во вспомогательном классе тестов TestTasksPrepareAndStoreService, но доступ снаружи есть только в класс IntegrationTestService)
он достаёт из ключа bookPlainTexts:bookSplitGuid:guid задачу, которая представляет собой это же поле bookText:bookGuid:guid и в значении находится плоский текст книги,
далее передаёт этот текст (типа TextSentence) в метод AddVersionViaHashToPlainText, расположенный здесь же

метод AddVersionViaHashToPlainText вычисляет хэш этого текста и передаёт его в метод ChechPlainTextVersionViaHash, расположенный здесь же

метод ChechPlainTextVersionViaHash возвращает максимальный номер версии хэша, найденный для этого номера книги
для этого метод получает вычисленное поле хранения в ключе вечного лога key-book-plain-texts-hashes-versions-list, 
оно состоит из номера книги (bookId), номера языка (languageId) и константы сдвига chapterFieldsShiftFactor таким образом, 
что книга с английским текстом имеет поле равное номеру книги, а её пара с русским текстом имеет поле, равное номеру книги и плюс константа сдвига 
(например, 79 и 1000079, формула - fieldBookIdWithLanguageId = bookId + languageId * chapterFieldsShiftFactor)
таким образом, имея номер книги, можно без перебора лога сразу получить хэш обоих тестов пары

далее возможны три варианта - первый, это ключа вечного лога нет вообще, тогда возвращается версия 0
по идее это возможно только при первом рабочем запуске, но пока идут одни тексты, вариант вполне актуален
если ключ есть, пробуем достать из него значение из полученного поля с номером книги, возможны два варианта - 
1. получили null, такого поля нет, такой книги в логе нет, возращается номер версии 0
2. получили значение типа List<TextSentence>, только без текстов, 
достаём из списка по очереди хэш и сравниваем его с помощью String.Equals с полученным хэшем в параметрах метода
если совпадение нашлось, сразу прерываем перебор и возвращаем -1 - такая версия книги уже существует и загрузка отменяется

как правило это будет относиться к обоим книгам пары, но надо решить, что делать если совпадает только одна книга из пары
если ничего не делать, то сейчас она одна запишется с новой версией и с этого момента номера версий двух языков пары перестанут совпадать - надо что-то решить по этому поводу

ну и последний вариант, все элементы списка проверены, совпадений хэшей не найдено, тогда надо вернуть максимальную найденную версию хэша
при переборе каждый раз версия сравнивается с максимальной, на старте равной 0 и на выходе мы имеем там максимальную найденную версию

получив обратнро в метод AddVersionViaHashToPlainText максимальную найденную версию хэша, рассматриваем 3 варианта - 
-1 - такая версия книги уже существует и сразу возвращаем null
получили 0, надо создать список и первый элемент в нём 
(из-за проблемы с сериализатором в расширении редиса нельзя положить в значение список с одним элементом, 
по дороге он превращается в просто элемент и после этого ситуация заходит в тупик) 
и положить в ключ новое поле с номером книги - значит такой книги ещё не было 
(возможно, надо и сам ключ создать, но это неважно - он создастся автоматически)




этот метод сравнивает полученный хэш с уже загруженными (хранящимися в вечном логе с ключом key-book-plain-texts-hashes-versions-list), 
если такой же хэш найден, то задача исключается из списка с пометкой, что уже существует (пока не реализовано, чтобы уведомлять контроллер)

оставшиеся задачи (если вообще что-то осталось, если ничего не осталось, вместо ключа-гуид пакета задач возвращается null) слегка обновляются - 
добавляется номер версии, создаваемый на основании уже существующих в логе версий этой же книги и собственно хэш плоского текста 
(на всякий случай - потом уйдёт на хранение в базе для контрольной сверки с логом)

после этого метод формирует пакет задач - создаётся новый ключ taskPackage:guid, в него записываются всё те же гуид-поля и в значения обновлённые плоские тексты

зачем создаётся ключ кафе для уведомления бэк-серверов, что есть пакет, за получение которого можно побороться, в поле и значение кладётся этот новый ключ пакета задач

далее тестовый метод проверяет появление ключа кафе и убеждается в его исчезновении - взятии бэк-сервером пакета на обработку

в планах контроль обработки пакета бэк-серверам до создания ключа обработанной книги (можно проверить соответствие хэша, переехавшего туда из плоского текста)

